---
title:  "A Helpful Mnemonic for 'git rebase' Arguments"
layout: section
---



<p>Para resumir a seção anterior, isso:</p>

<code>
  
  git checkout foo<br />
  git checkout -b newbar<br />
  git cherry-pick C D E <br />
  git checkout bar <br />
  git reset --hard newbar <br />
  git branch -d newbar

</code>

<p>é equivalente a isso:</p>

<code>
  
  git rebase foo bar

</code>

<p>Quando você faz um rebase, você está <em><strong>reescrevendo a história.</strong></em> Você está, efetivamente, dizendo para o Git, "Ei, você sabe essas coisas que aconteceram ali naquela linha do tempo completamente diferente? Em vez disso eu quero que você finja que elas aconteceram aqui."</p>

<p>A documentação para o comando rebase lista um monte de maneiras diferentes de invocá-lo. Francamente, eu ainda não tenho certeza do que algumas delas fazem, e eu tenho uma certa dificuldade para interpretar os diferentes parênteses e colchetes para descobrir exatamente como você usaria, por exemplo, <code class="inline">--onto</code>.</p>

<p>É assim que eu penso: em português, nós lemos <strong>da esquerda para a direita</strong>. Na maioria dos diagramas que mostram a mudança ao longo do tempo, o tempo é mostrado no eixo x do gráfico, com o tempo avançando <strong>da esquerda para a direita</strong>. Quando você executa comandos no shell, você pode por vários deles numa única linha, e eles serão executados na ordem <strong>da esquerda para a direita</strong>.</p>

<p>Então quando eu uso <code class="inline">git rebase</code>, eu <em>(quase)</em> sempre uso dois argumentos: o nome do lugar de onde eu quero começar, e o nome do lugar onde eu quero terminar. Ou, para dizer de outra forma, eu digo para o rebase a sequência de eventos que eu quero criar, <strong>da esquerda para a direita</strong>: <code class="inline">git rebase primeiro_isso depois_isso</code></p>
